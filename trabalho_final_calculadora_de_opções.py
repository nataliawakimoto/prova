# -*- coding: utf-8 -*-
"""Trabalho Final_Calculadora de Opções

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SovIsxaFG71V5VlGySTFv9cj_yF8Vltu
"""

import numpy as np
from scipy.stats import norm

def black_scholes_european(option_type, S, K, T, rf, sigma):
    d1 = (np.log(S / K) + (rf + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)

    if option_type == 'call':
        price = S * norm.cdf(d1) - K * np.exp(-rf * T) * norm.cdf(d2)
    elif option_type == 'put':
        price = K * np.exp(-rf * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    else:
        raise ValueError("option_type deve ser 'call' ou 'put'")

    return price

def binomial_american(option_type, S, K, T, rf, sigma, steps=100):
    dt = T / steps
    u = np.exp(sigma * np.sqrt(dt))
    d = 1 / u
    q = (np.exp(rf * dt) - d) / (u - d)

    asset_prices = np.zeros((steps + 1, steps + 1))
    option_values = np.zeros((steps + 1, steps + 1))

    for i in range(steps + 1):
        for j in range(i + 1):
            asset_prices[j, i] = S * (u ** (i - j)) * (d ** j)

    for j in range(steps + 1):
        if option_type == 'call':
            option_values[j, steps] = max(0, asset_prices[j, steps] - K)
        elif option_type == 'put':
            option_values[j, steps] = max(0, K - asset_prices[j, steps])

    for i in range(steps - 1, -1, -1):
        for j in range(i + 1):
            exercise_value = max(0, (asset_prices[j, i] - K) if option_type == 'call' else (K - asset_prices[j, i]))
            hold_value = np.exp(-rf * dt) * (q * option_values[j, i + 1] + (1 - q) * option_values[j + 1, i + 1])
            option_values[j, i] = max(exercise_value, hold_value)

    return option_values[0, 0]

def monte_carlo_asian(option_type, S, K, T, rf, sigma, simulations=10000, steps=100):
    dt = T / steps
    payoffs = []

    for _ in range(simulations):
        path = [S]
        for _ in range(steps):
            z = np.random.normal()
            St = path[-1] * np.exp((rf - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * z)
            path.append(St)
        average_price = np.mean(path)

        if option_type == 'call':
            payoffs.append(max(0, average_price - K))
        elif option_type == 'put':
            payoffs.append(max(0, K - average_price))

    price = np.exp(-rf * T) * np.mean(payoffs)
    return price

def calculate_option_price(option_style, option_type, S, K, T, rf, sigma):
    if option_style == 'european':
        return black_scholes_european(option_type, S, K, T, rf, sigma)
    elif option_style == 'american':
        return binomial_american(option_type, S, K, T, rf, sigma)
    elif option_style == 'asian':
        return monte_carlo_asian(option_type, S, K, T, rf, sigma)
    else:
        raise ValueError("option_style deve ser 'european', 'american' ou 'asian'")

# Coleta de entradas do usuário
option_style = input("Digite o tipo de opção (european, american, asian): ").lower()
option_type = input("Digite 'call' para opção de compra ou 'put' para opção de venda: ").lower()
S = float(input("Digite o preço atual do ativo subjacente: "))
K = float(input("Digite o preço de exercício: "))
T = float(input("Digite o tempo até o vencimento (em anos): "))
rf = float(input("Digite a taxa de juros livre de risco: "))
sigma = float(input("Digite a volatilidade do ativo subjacente: "))

# Cálculo e exibição do preço da opção
price = calculate_option_price(option_style, option_type, S, K, T, rf, sigma)
print(f"O preço da opção {option_style} {option_type} é: {price:.2f}")